# Redis集群模式
## 主从复制模式：多副本
 多副本方案优势
 1. 缩短不可用时间：master 发生宕机，我们可以手动把 slave 提升为 master 继续提供服务。
 2. 提升读性能：让 slave 分担一部分读请求，提升应用的整体性能。
 
 ![alt](https://gitee.com/afeiei/img-hosting/raw/master/Redis/001.png)


 劣势
 * 当master宕机时，我们需要手动把 slave 提升为 master，这个过程也是需要花费时间的。一旦需要人工介入，就必须要算上人的反应时间、操作时间，所以，在这期间你的业务应用依旧会受到影响。
 
## Sentinel（哨兵）模式：故障自动切换
 引入一个观察者去实时监测 master 的健康状态，这个观察者就是哨兵。
 1. 哨兵每间隔一段时间，询问 master 是否正常。
 2. master 正常回复，表示状态正常，回复超时表示异常。
 3. 哨兵发现异常，发起主从切换。

 ![alt](https://gitee.com/afeiei/img-hosting/raw/master/Redis/002.png)

 这里还有一个问题，如果 master 状态正常，但这个哨兵在询问 master 时，它们之间的网络发生了问题，那这个哨兵可能会误判。  
 ![alt](https://gitee.com/afeiei/img-hosting/raw/master/Redis/003.png)

 这个问题怎么解决  

 答案是，我们可以部署多个哨兵，让它们分布在不同的机器上，它们一起监测 master 的状态，流程就变成了这样：
 1. 多个哨兵每间隔一段时间，询问 master 是否正常
 2. master 正常回复，表示状态正常，回复超时表示异常
 3. 一旦有一个哨兵判定 master 异常（不管是否是网络问题），就询问其它哨兵，如果多个哨兵（设置一个阈值）都认为 master 异常了，这才判定 master 确实发生了故障
 4. 多个哨兵经过协商后，判定 master 故障，则发起主从切换

 哨兵协商判定 master 异常后，这里还有一个问题：由哪个哨兵来发起主从切换呢？

 答案是，选出一个哨兵「领导者」，由这个领导者进行主从切换。

 在选举哨兵领导者时，我们可以制定这样一个选举规则：

 1. 每个哨兵都询问其它哨兵，请求对方为自己投票
 2. 每个哨兵只投票给第一个请求投票的哨兵，且只能投票一次
 3. 首先拿到超过半数投票的哨兵，当选为领导者，发起主从切换

 其实，这个选举的过程就是我们经常听到的：分布式系统领域中的「共识算法」。


 现在，我们用多个哨兵共同监测 Redis 的状态，这样一来，就可以避免误判的问题了，架构模型就变成了这样：

 ![alt](https://gitee.com/afeiei/img-hosting/raw/master/Redis/004.png)
 
 随着时间的发展，你的业务体量开始迎来了爆炸性增长，此时你的架构模型，还能够承担这么大的流量吗？

 我们一起来分析一下：

 1. 稳定性：Redis 故障宕机，我们有哨兵 + 副本，可以自动完成主从切换
 2. 性能：读请求量增长，我们可以再部署多个 slave，读写分离，分担读压力
 3. 性能：写请求量增长，但我们只有一个 master 实例，这个实例达到瓶颈怎么办？

 看到了么，当你的写请求量越来越大时，一个 master 实例可能就无法承担这么大的写流量了。

 要想完美解决这个问题，此时你就需要考虑使用分片集群了。

 ## 分片集群模式
 分片集群简单来说就是一个实例扛不住写压力，那我们是否可以部署多个实例，然后把这些实例按照一定规则组织起来，把它们当成一个整体，对外提供服务，这样不就可以解决集中写一个实例的瓶颈问题吗？

 所以，现在的架构模型就变成了这样：
 ![alt](https://gitee.com/afeiei/img-hosting/raw/master/Redis/005.png)
 
 我们制定规则如下：
  1. 每个节点各自存储一部分数据，所有节点数据之和才是全量数据。
  2. 制定一个路由规则，对于不同的key，把它路由到固定一个实例上进行读写。

  客户端分片指的是，key 的路由规则放在客户端来做，就是下面这样：

  ![alt](https://gitee.com/afeiei/img-hosting/raw/master/Redis/006.png)

  这个方案的缺点是，客户端需要维护这个路由规则，也就是说，你需要把路由规则写到你的业务代码中。

如何做到不把路由规则耦合在业务代码中呢？你可以这样优化，把这个路由规则封装成一个模块，当需要使用时，集成这个模块就可以了。

这就是 Redis Cluster 的采用的方案。

![alt](https://gitee.com/afeiei/img-hosting/raw/master/Redis/007.png)

Redis Cluster 内置了哨兵逻辑，无需再部署哨兵。

[参考链接](https://mp.weixin.qq.com/s/x1AobPWpMufNWqrBnc5sZg)
